opt.weights = portfolio.optim(returns, ps=tarket_risk/sqrt(250), shorts = short)$pw
if (short == FALSE){
opt.weights = pmax(opt.weights, 0) #Correct approximation error
opt.weights = opt.weights/sum(opt.weights)
}
return (opt.weights)
}
#TMP
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point()
ef_w = findEfficientFrontier.Risk(returns, target_risk)
ef_ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[1]
ef_ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[1]
ef_risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[2]
ef_ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[1]]
ef_risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
target_risk = 0.1/sqrt(250)
# By target risk
findEfficientFrontier.Risk = function(zoo, target_risk, short = FALSE){
#Calculate optimal weights
opt.weights = portfolio.optim(returns, ps=tarket_risk, shorts = short)$pw
if (short == FALSE){
opt.weights = pmax(opt.weights, 0) #Correct approximation error
opt.weights = opt.weights/sum(opt.weights)
}
return (opt.weights)
}
#TMP
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point()
target_risk = 0.1/sqrt(250)
ef_w = findEfficientFrontier.Risk(returns, target_risk)
ef_ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[1]]
ef_risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
install.packages("ROML")
# By target risk
findEfficientFrontier.Risk = function(zoo, target_risk, short = FALSE){
#Calculate optimal weights
opt.weights = portfolio.optim(returns, ps=target_risk, shorts = short)$pw
if (short == FALSE){
opt.weights = pmax(opt.weights, 0) #Correct approximation error
opt.weights = opt.weights/sum(opt.weights)
}
return (opt.weights)
}
#TMP
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point()
target_risk = 0.1/sqrt(250)
ef_w = findEfficientFrontier.Risk(returns, target_risk)
ef_ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[1]]
ef_risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
names(df)
library(dplyr)
library(tibble)
from = as.Date("2018-01-01")
to = as.Date("2018-03-01")
df_range = df %>% rownames_to_column("date") %>%
filter(as.Date(date)>=from & as.Date(date) <= to) %>% column_to_rownames("date")
View(df_range)
wght = c(0.3,0.1,0.15,0.05,0.1,0.1)
sum(wght)
wght = c(0.3,0.1,0.15,0.05,0.18,0.22)
sum(wght)
#Create weight dataframe
wght_df = data.frame(date=row.names(df_range))
View(wght_df)
shiny::runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
?fluidPage
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
?DEOptim
library(DEoptim)
?DEOptim
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(ggthemes)
library(plotly)
library(xts)
library(RColorBrewer)
source('./func/am_helper.R')
#########################################
# Part 1 for Theory descriprion
#########################################
df = read.csv('./data/returns.csv', row.names = 'date')
df = df[rownames(df)<"2018-10-01",]
# Convert to zoo
returns = xts(df, order.by = as.Date(rownames(df)))
# Calculate annualized mean returns, sd of returns and covariance
mean_ret = apply(returns, 2, mean) * 250
sd_ret = apply(returns, 2, sd) * sqrt(250)
cov_matrix = cov(returns) * 250
#  Plot graph 1
df1 = data.frame(Asset = colnames(df), Return = mean_ret, Risk = sd_ret)
g1 = ggplot(df1, aes(x=Risk, y=Return, label=Asset)) + geom_point(color="steelblue3")  +
xlab('Risk (standard deviation of returns, annualized)') + ylab('Average Returns, annualized') +
xlim(0, 0.4) + ylim(0,0.1) + theme_hc()
g1 = ggplotly(g1, tooltip = c("x","y"), width = 600) %>%   add_annotations(x = df1$Risk,
y = df1$Return,
text = df1$Asset,
xref = "x",
yref = "y",
showarrow = TRUE,
arrowhead = 4,
arrowsize = .5,
ax = 50,
ay = -20)
g1$x$data[[1]]$text = paste("Return:", round(df1$Return, 4) * 100, "%","<br>",
"Risk:", round(df1$Risk, 4) * 100, "%")
g1 = g1 %>% layout(margin = list(b = 50, l = 50, t = 100), title = "Risk/Return of Assets <br> (annualized) 2000 - 3Q2018")
# Plot graph 2
risk_ret_ann = df %>% mutate(date = as.Date(rownames(df))) %>%
gather(key = "Asset", value="Return", -date) %>%
mutate(year = year(date)) %>%
group_by(Asset, year) %>%
summarize(av_ret = mean(Return)*250, Risk = sd(Return)*sqrt(250) ) %>%
rename(Return=av_ret)
g2 = ggplot(risk_ret_ann, aes(x=Risk, y=Return, text = paste(year,"<br>","Return:",
round(Return,4)*100,"%","<br>", "Risk:", round(Risk,4)*100,"%"))) +
geom_point(color="steelblue3")  +
xlab('Risk (standard deviation of returns, annualized)') +
ylab('Average Returns, annualized') +
theme_hc() + facet_wrap(~reorder(Asset, Risk, sd))
g2 = ggplotly(g2, tooltip = c("text"), width = 600)
g2[['x']][['layout']][['annotations']][[1]][['y']] = -0.1 #Move y-label lower
g2 = g2 %>% layout(margin = list(b = 50, l = 50, t = 120), title = "Risk/Return of Assets By Years <br> (annualized) 2000 - 3Q2018")
# Plot graph 3
order = risk_ret_ann %>% group_by(Asset) %>% summarise(sd_SD=sd(Risk)) %>% arrange(sd_SD) %>% select(Asset)
order = order[['Asset']]
risk_ret_cum = df %>% mutate(date=rownames(df)) %>%
gather(key="Asset", value="Return", -date) %>%
group_by(Asset) %>%
arrange(date) %>%
mutate(cumRet = cumprod(1+Return) - 1)
# Re-arrange
risk_ret_cum$facet = factor(risk_ret_cum$Asset, levels = c(order))
g3 = ggplot(risk_ret_cum, aes(x=as.Date(date), y=cumRet, text = paste(date,"<br>", "Compound return:", round(cumRet,4)*100,"%"), group=1)) + geom_line(color="steelblue3") + facet_wrap(~facet) + scale_x_date(date_breaks = "5 years", date_labels =  "%y") + xlab('Years') + ylab('Compound Return') + theme_hc()
g3 = ggplotly(g3, tooltip = "text", width = 600)
g3[['x']][['layout']][['annotations']][[1]][['y']] = -0.1 #Move y-label lower
g3 = g3 %>% layout(margin = list(b = 50, l = 50, t = 120), title = "Compound Return <br> 2000 - 3Q2018")
# Plot graph 4
# Sim portfolios were simulated using am_helper.R (simPortfolios)
sim_port = read.csv("./data/sim_port.csv")
#Calculate the EF line
min_tret = sim_port[sim_port$Risk==min(sim_port$Risk), "Return"][[1]]  #Usually a good starting point
max_tret = max(sim_port$Return)
tret_vector = seq(min_tret, max_tret, length.out = 20)
ef_line = data.frame(Risk = rep(NA, length(tret_vector)), Return = rep(NA, length(tret_vector)),
Portfolio = rep(NA, length(tret_vector))) #Place holder
i =1 #counter
for (ret in tret_vector){
ef_w = findEfficientFrontier.Return(returns, ret)
tmp.Ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[1]]
tmp.Risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
ef_line[i,'Return'] = tmp.Ret
ef_line[i,'Risk'] = tmp.Risk
ef_line[i, 'Portfolio'] = paste(c(colnames(df)),
paste(as.character(round(ef_w, 4)*100), "%"), sep=": ", collapse = "<br>")
i = i+1
}
g4 = ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(data=sim_port, aes(x=Risk, y=Return), color='gray', alpha=0.5) +
geom_line(data=ef_line, aes(x=Risk, y=Return, text = Portfolio, group=1), color='steelblue3', size =2, alpha=0.5) +
ylim(0,0.10) + theme_hc() + xlab('Risk (standard deviation of returns, annualized)') + ylab('Average Returns, annualized') +
theme(panel.background = element_rect(fill = "transparent"))
g4 = ggplotly(g4, tooltip = "text", width = 600)
g4 = g4 %>% layout(margin = list(b = 50, l = 50, t = 120), title = "Simulated Portfolios and the Optimal Line")
############################################################
##  BackTesting
############################################################
date_choices = seq(as.Date("2000-01-01"), as.Date("2018-10-01"), by="1 month")
date_choices[length(date_choices)] = as.Date("2018-09-30")
#load risk-free rates
rf = read.csv("./data/rf.csv")
setwd("~/Documents/NYCDSA/Projects/AMShiny/AMShinyApp/")
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(ggthemes)
library(plotly)
library(xts)
library(RColorBrewer)
source('./func/am_helper.R')
#########################################
# Part 1 for Theory descriprion
#########################################
df = read.csv('./data/returns.csv', row.names = 'date')
df = df[rownames(df)<"2018-10-01",]
# Convert to zoo
returns = xts(df, order.by = as.Date(rownames(df)))
# Calculate annualized mean returns, sd of returns and covariance
mean_ret = apply(returns, 2, mean) * 250
sd_ret = apply(returns, 2, sd) * sqrt(250)
cov_matrix = cov(returns) * 250
#  Plot graph 1
df1 = data.frame(Asset = colnames(df), Return = mean_ret, Risk = sd_ret)
g1 = ggplot(df1, aes(x=Risk, y=Return, label=Asset)) + geom_point(color="steelblue3")  +
xlab('Risk (standard deviation of returns, annualized)') + ylab('Average Returns, annualized') +
xlim(0, 0.4) + ylim(0,0.1) + theme_hc()
g1 = ggplotly(g1, tooltip = c("x","y"), width = 600) %>%   add_annotations(x = df1$Risk,
y = df1$Return,
text = df1$Asset,
xref = "x",
yref = "y",
showarrow = TRUE,
arrowhead = 4,
arrowsize = .5,
ax = 50,
ay = -20)
g1$x$data[[1]]$text = paste("Return:", round(df1$Return, 4) * 100, "%","<br>",
"Risk:", round(df1$Risk, 4) * 100, "%")
g1 = g1 %>% layout(margin = list(b = 50, l = 50, t = 100), title = "Risk/Return of Assets <br> (annualized) 2000 - 3Q2018")
# Plot graph 2
risk_ret_ann = df %>% mutate(date = as.Date(rownames(df))) %>%
gather(key = "Asset", value="Return", -date) %>%
mutate(year = year(date)) %>%
group_by(Asset, year) %>%
summarize(av_ret = mean(Return)*250, Risk = sd(Return)*sqrt(250) ) %>%
rename(Return=av_ret)
g2 = ggplot(risk_ret_ann, aes(x=Risk, y=Return, text = paste(year,"<br>","Return:",
round(Return,4)*100,"%","<br>", "Risk:", round(Risk,4)*100,"%"))) +
geom_point(color="steelblue3")  +
xlab('Risk (standard deviation of returns, annualized)') +
ylab('Average Returns, annualized') +
theme_hc() + facet_wrap(~reorder(Asset, Risk, sd))
g2 = ggplotly(g2, tooltip = c("text"), width = 600)
g2[['x']][['layout']][['annotations']][[1]][['y']] = -0.1 #Move y-label lower
g2 = g2 %>% layout(margin = list(b = 50, l = 50, t = 120), title = "Risk/Return of Assets By Years <br> (annualized) 2000 - 3Q2018")
# Plot graph 3
order = risk_ret_ann %>% group_by(Asset) %>% summarise(sd_SD=sd(Risk)) %>% arrange(sd_SD) %>% select(Asset)
order = order[['Asset']]
risk_ret_cum = df %>% mutate(date=rownames(df)) %>%
gather(key="Asset", value="Return", -date) %>%
group_by(Asset) %>%
arrange(date) %>%
mutate(cumRet = cumprod(1+Return) - 1)
# Re-arrange
risk_ret_cum$facet = factor(risk_ret_cum$Asset, levels = c(order))
g3 = ggplot(risk_ret_cum, aes(x=as.Date(date), y=cumRet, text = paste(date,"<br>", "Compound return:", round(cumRet,4)*100,"%"), group=1)) + geom_line(color="steelblue3") + facet_wrap(~facet) + scale_x_date(date_breaks = "5 years", date_labels =  "%y") + xlab('Years') + ylab('Compound Return') + theme_hc()
g3 = ggplotly(g3, tooltip = "text", width = 600)
g3[['x']][['layout']][['annotations']][[1]][['y']] = -0.1 #Move y-label lower
g3 = g3 %>% layout(margin = list(b = 50, l = 50, t = 120), title = "Compound Return <br> 2000 - 3Q2018")
# Plot graph 4
# Sim portfolios were simulated using am_helper.R (simPortfolios)
sim_port = read.csv("./data/sim_port.csv")
#Calculate the EF line
min_tret = sim_port[sim_port$Risk==min(sim_port$Risk), "Return"][[1]]  #Usually a good starting point
max_tret = max(sim_port$Return)
tret_vector = seq(min_tret, max_tret, length.out = 20)
ef_line = data.frame(Risk = rep(NA, length(tret_vector)), Return = rep(NA, length(tret_vector)),
Portfolio = rep(NA, length(tret_vector))) #Place holder
i =1 #counter
for (ret in tret_vector){
ef_w = findEfficientFrontier.Return(returns, ret)
tmp.Ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[1]]
tmp.Risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
ef_line[i,'Return'] = tmp.Ret
ef_line[i,'Risk'] = tmp.Risk
ef_line[i, 'Portfolio'] = paste(c(colnames(df)),
paste(as.character(round(ef_w, 4)*100), "%"), sep=": ", collapse = "<br>")
i = i+1
}
g4 = ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(data=sim_port, aes(x=Risk, y=Return), color='gray', alpha=0.5) +
geom_line(data=ef_line, aes(x=Risk, y=Return, text = Portfolio, group=1), color='steelblue3', size =2, alpha=0.5) +
ylim(0,0.10) + theme_hc() + xlab('Risk (standard deviation of returns, annualized)') + ylab('Average Returns, annualized') +
theme(panel.background = element_rect(fill = "transparent"))
g4 = ggplotly(g4, tooltip = "text", width = 600)
g4 = g4 %>% layout(margin = list(b = 50, l = 50, t = 120), title = "Simulated Portfolios and the Optimal Line")
############################################################
##  BackTesting
############################################################
date_choices = seq(as.Date("2000-01-01"), as.Date("2018-10-01"), by="1 month")
date_choices[length(date_choices)] = as.Date("2018-09-30")
#load risk-free rates
rf = read.csv("./data/rf.csv")
g4
to = as.Date("2015-01-01")
from = as.Date("2018-01-01")
df_tmp = df %>% mutate(date = as.Date(row.names(df)))
# Keep only relevant dates
df_tmp = dplyr::filter(df_tmp, date >= from & date<=to)
from = as.Date("2015-01-01")
to = as.Date("2018-01-01")
df_tmp = df %>% mutate(date = as.Date(row.names(df)))
# Keep only relevant dates
df_tmp = dplyr::filter(df_tmp, date >= from & date<=to)
reb_dates = df_tmp$date %>% group_by(year(date), month(date)) %>% arrange(day(date)) %>% head(1)
reb_dates = df_tmp %>% group_by(year(date), month(date)) %>% arrange(day(date)) %>% head(1) %>% select(date)
View(reb_dates)
View(reb_dates)
reb_dates = df_tmp %>% mutate(year = year(date), month=month(date), day=day(date)) %>%
group_by(year, month) %>% arrange(day) %>% head(1) %>% select(date)
reb_dates = df_tmp %>% mutate(year = year(date), month=month(date), day=day(date))
View(reb_dates)
reb_dates = df_tmp %>% mutate(yr = year(date), mnth=month(date), dy=day(date)) %>%
group_by(yr, mnth) %>% arrange(dy) %>% head(1) %>% select(date)
reb_dates = df_tmp %>% mutate(year = year(date), month=month(date), day=day(date))
reb_dates = reb_dates %>% group_by(year, month) %>% arrange(day) %>% head(1) %>% select(date)
reb_dates = df_tmp %>% mutate(year = year(date), month=month(date), day=day(date))
View(reb_dates)
df_tmp = df %>% mutate(date = as.Date(row.names(df)))
reb_dates = df_tmp %>% mutate(year = year(date), month=month(date), day=day(date))
#Add year, quarter, month, day
reb_dates = df_tmp %>% mutate(year = year(date), month=month(date), quarter = quarter(date), day=day(date))
View(reb_dates)
#Add year, quarter, month, day
df_tmp = df_tmp %>% mutate(year = year(date), month=month(date), quarter = quarter(date), day=day(date))
reb_dates = df_tmp %>% group_(year, month) %>% summarize(n=n())
reb_dates = df_tmp %>% group_by(year, month) %>% summarize(n=n())
View(reb_dates)
View(reb_dates)
reb_dates = df_tmp %>% group_by(year, month)  %>% arrange(day)
reb_dates = df_tmp %>% group_by(year, month)  %>% arrange(day) %>% head(1)
reb_dates = df_tmp %>% arrange(date) %>% group_by(year, month) %>% head(1)
reb_dates = df_tmp %>% arrange(date) %>% group_by(year, month) %>% n_th(1)
reb_dates = df_tmp %>% arrange(date) %>% group_by(year, month) %>% head(.,1)
reb_dates = df_tmp %>% arrange(date) %>% group_by(year, month) %>% filter(day = min(day))
reb_dates = df_tmp %>% arrange(date) %>% group_by(year, month) %>% filter(day == min(day))
View(reb_dates)
reb_dates = df_tmp %>% arrange(date) %>% group_by(year, month) %>% filter(day == min(day)) %>% select(date)
View(reb_dates)
reb_dates = df_tmp %>% arrange(date) %>% group_by(year, month) %>% filter(day == min(day))%>% ungroup() %>% select(date)
View(reb_dates)
w_tmp = rep(1/6,6)
target_ret = t(w_tmp) %*% s
mean_ret = apply(df_tmp[,1:6], 2, mean) * 250
df_tmp = df %>% mutate(date = as.Date(row.names(df)))
# Keep only relevant dates
df_tmp = dplyr::filter(df_tmp, date >= from & date<=to)
#Add year, quarter, month, day
df_tmp = df_tmp %>% mutate(year = year(date), month=month(date), quarter = quarter(date), day=day(date))
mean_ret = apply(df_tmp[,1:6], 2, mean) * 250
apply(df_tmp,2,mean) * 250
apply(df_tmp[,1:6],2,mean) * 250
apply(df[,1:6],2,mean) * 250
cov_matrix = cov(df[,1:6])
target_ret = t(w_tmp) %*% mean_ret
target_risk = sqrt(t(w_tmp) * cov_matrix * w_tmp)
target_risk = sqrt(t(w_tmp) %*% cov_matrix %*% w_tmp * 250)
#Find optimal portfolio (Same Ret)
ret_zoo = xts(df_tmp, order.by = date)
View(df_tmp)
#Find optimal portfolio (Same Ret)
ret_zoo = xts(df_tmp, order.by = as.Date(date))
#Find optimal portfolio (Same Ret)
ret_zoo = xts(df_tmp, order.by = as.Date(df_tmp$date))
View(ret_zoo)
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>% summarize(weight = findEfficientFrontier.Return(.,target_ret))
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>% summarize(weight1 = findEfficientFrontier.Return(.,target_ret)[1])
View(opt_weights)
## Function that finds weights of assets on the efficient frontier
# By target return
findEfficientFrontier.Return = function(df, target_ret, short = FALSE){
returns = xts(df, order_by=as.Date(df$date))
#Calculate optimal weights
opt.weights = portfolio.optim(returns, pm=target_ret/250, shorts = short)$pw
if (short == FALSE){
opt.weights = pmax(opt.weights, 0) #Correct approximation error
opt.weights = opt.weights/sum(opt.weights)
}
return (opt.weights)
}
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>%
select(Russell2000,EuropeStocks,EMStocks,Treasury,CorpBonds, RealEstate, date) %>%
do(weight = findEfficientFrontier.Return(., target_ret))
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>%
select(Russell2000,EuropeStocks,EMStocks,Treasury,CorpBonds, RealEstate, date)
View(opt_weights)
# By target return alternative
findEfficientFrontier.ReturnALT = function(mean_ret, cov_matrix, target_ret){
obj_func = function(w){
#To avoid NA
if (sum(w) ==0){
w = w + 1e-10}
#Balance to one
w = w/sum(w)
#Calculate negative return
p_ret = - t(w) %*% mean_ret
risk = sqrt(t(w) %*% cov_matrix %*% w)
return(risk + abs(p_ret - target_ret)) #Penalized optimization
}
# Set parameters
controlDE <- list(reltol=.000001,steptol=150, itermax = 10000,trace = 5000,
strategy=1, c=0)
#Long only
N = length(mean_ret)
lower = rep(0,N)
upper = rep(1,N)
out <- DEoptim(fn = obj_func, lower = lower, upper = upper, control = controlDE)
opt_w = out$optim$bestmem
opt_w = opt_w/sum(opt_w) #Sum up to 1
return(opt_w)
}
# By target return alternative
findEfficientFrontier.ReturnALT = function(df, target_ret, names){
mean_ret = apply(df[,names],2,mean) * 250
cov_matrix = cov(df[,names]) * 250
obj_func = function(w){
#To avoid NA
if (sum(w) ==0){
w = w + 1e-10}
#Balance to one
w = w/sum(w)
#Calculate negative return
p_ret = - t(w) %*% mean_ret
risk = sqrt(t(w) %*% cov_matrix %*% w)
return(risk + abs(p_ret - target_ret)) #Penalized optimization
}
# Set parameters
controlDE <- list(reltol=.000001,steptol=150, itermax = 10000,trace = 5000,
strategy=1, c=0)
#Long only
N = length(mean_ret)
lower = rep(0,N)
upper = rep(1,N)
out <- DEoptim(fn = obj_func, lower = lower, upper = upper, control = controlDE)
opt_w = out$optim$bestmem
opt_w = opt_w/sum(opt_w) #Sum up to 1
return(opt_w)
}
# Create a dataframe with portfolio and benchmark returns
names = colnames(df)
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>%
do(findEfficientFrontier.ReturnALT(., target_ret, names))
View(opt_weights)
mean_ret = apply(df[,names],2,mean) * 250
cov_matrix = cov(df[,names]) * 250
#Calculate negative return
p_ret = - t(w) %*% mean_ret
w = rep(1/6,6)
#Calculate negative return
p_ret = - t(w) %*% mean_ret
risk = sqrt(t(w) %*% cov_matrix %*% w)
risk + abs(p_ret - target_ret)
# By target return alternative
findEfficientFrontier.ReturnALT = function(df, target_ret, names){
mean_ret = apply(df[,names],2,mean) * 250
cov_matrix = cov(df[,names]) * 250
obj_func = function(w){
#To avoid NAN
w = w + 1e-10}
#Balance to one
w = w/sum(w)
#Calculate negative return
p_ret = - t(w) %*% mean_ret
risk = sqrt(t(w) %*% cov_matrix %*% w)
return(risk + abs(p_ret - target_ret)) #Penalized optimization
}
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>%
do(findEfficientFrontier.ReturnALT(., target_ret, names))
# Create a dataframe with portfolio and benchmark returns
names = colnames(df)
df_tmp = df %>% mutate(date = as.Date(row.names(df)))
# Keep only relevant dates
df_tmp = dplyr::filter(df_tmp, date >= from & date<=to)
#Add year, quarter, month, day
df_tmp = df_tmp %>% mutate(year = year(date), month=month(date), quarter = quarter(date), day=day(date))
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>%
do(findEfficientFrontier.ReturnALT(., target_ret, names))
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>%
do(w1=findEfficientFrontier.ReturnALT(., target_ret, names)[1])
View(opt_weights)
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>%
do(w1=findEfficientFrontier.ReturnALT(., target_ret, names)[1],
w2=findEfficientFrontier.ReturnALT(., target_ret, names)[2],
w3=findEfficientFrontier.ReturnALT(., target_ret, names)[3],
w4=findEfficientFrontier.ReturnALT(., target_ret, names)[4],
w5=findEfficientFrontier.ReturnALT(., target_ret, names)[5],
w6=findEfficientFrontier.ReturnALT(., target_ret, names)[6])
View(opt_weights)
findEfficientFrontier.ReturnALT(., target_ret, names)
findEfficientFrontier.ReturnALT(df_tmp, target_ret, names)
# By target return alternative
findEfficientFrontier.ReturnALT = function(df, target_ret, names){
mean_ret = apply(df[,names],2,mean) * 250
cov_matrix = cov(df[,names]) * 250
obj_func = function(w){
#To avoid NAN
w = w + 1e-10
#Balance to one
w = w/sum(w)
#Calculate negative return
p_ret = - t(w) %*% mean_ret
risk = sqrt(t(w) %*% cov_matrix %*% w)
return(risk + abs(p_ret - target_ret)) #Penalized optimization
}
# Set parameters
controlDE <- list(reltol=.000001,steptol=150, itermax = 10000,trace = 5000,
strategy=1, c=0)
#Long only
N = length(mean_ret)
lower = rep(0,N)
upper = rep(1,N)
out <- DEoptim(fn = obj_func, lower = lower, upper = upper, control = controlDE)
opt_w = out$optim$bestmem
opt_w = opt_w/sum(opt_w) #Sum up to 1
return(opt_w)
}
findEfficientFrontier.ReturnALT(df_tmp, target_ret, names)
check_w=findEfficientFrontier.ReturnALT(df_tmp, target_ret, names)
calcPortPerformance(check_w,apply(df_tmp,2,mean), cov_matrix(df_tmp))
calcPortPerformance(check_w,apply(df_tmp,2,mean), cov_matrix(df_tmp))
apply(df_tmp,2,mean)
opt_weights = df_tmp %>% arrange(date) %>% group_by(year, month) %>%
do(w1=findEfficientFrontier.ReturnALT(., target_ret, names)[1],
w2=findEfficientFrontier.ReturnALT(., target_ret, names)[2],
w3=findEfficientFrontier.ReturnALT(., target_ret, names)[3],
w4=findEfficientFrontier.ReturnALT(., target_ret, names)[4],
w5=findEfficientFrontier.ReturnALT(., target_ret, names)[5],
w6=findEfficientFrontier.ReturnALT(., target_ret, names)[6])
