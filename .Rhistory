ef_risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
target_risk = 0.1/sqrt(250)
# By target risk
findEfficientFrontier.Risk = function(zoo, target_risk, short = FALSE){
#Calculate optimal weights
opt.weights = portfolio.optim(returns, ps=tarket_risk, shorts = short)$pw
if (short == FALSE){
opt.weights = pmax(opt.weights, 0) #Correct approximation error
opt.weights = opt.weights/sum(opt.weights)
}
return (opt.weights)
}
#TMP
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point()
target_risk = 0.1/sqrt(250)
ef_w = findEfficientFrontier.Risk(returns, target_risk)
ef_ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[1]]
ef_risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
install.packages("ROML")
# By target risk
findEfficientFrontier.Risk = function(zoo, target_risk, short = FALSE){
#Calculate optimal weights
opt.weights = portfolio.optim(returns, ps=target_risk, shorts = short)$pw
if (short == FALSE){
opt.weights = pmax(opt.weights, 0) #Correct approximation error
opt.weights = opt.weights/sum(opt.weights)
}
return (opt.weights)
}
#TMP
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point()
target_risk = 0.1/sqrt(250)
ef_w = findEfficientFrontier.Risk(returns, target_risk)
ef_ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[1]]
ef_risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
names(df)
library(dplyr)
library(tibble)
from = as.Date("2018-01-01")
to = as.Date("2018-03-01")
df_range = df %>% rownames_to_column("date") %>%
filter(as.Date(date)>=from & as.Date(date) <= to) %>% column_to_rownames("date")
View(df_range)
wght = c(0.3,0.1,0.15,0.05,0.1,0.1)
sum(wght)
wght = c(0.3,0.1,0.15,0.05,0.18,0.22)
sum(wght)
#Create weight dataframe
wght_df = data.frame(date=row.names(df_range))
View(wght_df)
shiny::runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
?fluidPage
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
runApp('Documents/NYCDSA/Projects/AMShiny/AMShinyApp')
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(ggthemes)
library(plotly)
library(xts)
library(RColorBrewer)
source('./func/am_helper.R')
setwd("~/Documents/NYCDSA/Projects/AMShiny/AMShinyApp/")
df = read.csv('./data/returns.csv', row.names = 'date')
df = df[rownames(df)<"2018-10-01",]
returns = xts(df, order.by = as.Date(row.names(df)))
# Function that calculates portfolio return/risk given mean returns of assets and a covariance matrix
calcPortPerformance = function(weights, mean_ret, cov_matrix){
portRet =  t(weights) %*% mean_ret
portRisk =  sqrt(t(weights) %*% (cov_matrix %*% weights))
return (list(portRet, portRisk))
}
## Function that simulates portfolio risk/return given mean returns of assets and a covariance matrix
simPortfolios = function(mean_ret, cov_matrix, nsim=10000){
n_assets = length(mean_ret) #Get number of assets
#Create empty DataFrame
result = data.frame(Return = rep(NA,nsim), Risk = rep(NA, nsim))
#Simulate portfolios performance and populate the resulting dataframe
for (i in 1:nsim){
weights = runif(n_assets, 0, 1)  #Simulate normal distribution
weights = weights/sum(weights)      #Make sure that weights add up to 1.0
portRet = calcPortPerformance(weights, mean_ret, cov_matrix) [[1]]
portRisk = calcPortPerformance(weights, mean_ret, cov_matrix) [[2]]
result$Return[i] = portRet
result$Risk[i] = portRisk
}
return (result)
}
## Function that finds weights of assets on the efficient frontier
# By target return
findEfficientFrontier.Return = function(zoo, target_ret, short = FALSE){
#Calculate optimal weights
opt.weights = portfolio.optim(returns, pm=ret/250, shorts = short)$pw
if (short == FALSE){
opt.weights = pmax(opt.weights, 0) #Correct approximation error
opt.weights = opt.weights/sum(opt.weights)
}
return (opt.weights)
}
# By target risk
# findEfficientFrontier.Risk = function(zoo, target_risk, short = FALSE){
#
#   #Calculate optimal weights
#   opt.weights = portfolio.optim(returns, ps=target_risk, shorts = short)$pw
#
#   if (short == FALSE){
#     opt.weights = pmax(opt.weights, 0) #Correct approximation error
#
#     opt.weights = opt.weights/sum(opt.weights)
#   }
#
#   return (opt.weights)
# }
#
# #TMP
# ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point()
# target_risk = 0.1/sqrt(250)
#
# ef_w = findEfficientFrontier.Risk(returns, target_risk)
# ef_ret = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[1]]
# ef_risk = calcPortPerformance(ef_w, mean_ret, cov_matrix)[[2]]
#Function that calculates portfolio returns
calcPortReturn = function(df, from, to, wght, rebalance){
#Cut dataframe to reflect date range
df_range = df %>% rownames_to_column("date") %>%
filter(as.Date(date)>=from & as.Date(date) <= to) %>% column_to_rownames("date")
df_range = xts(df_range, order.by = as.Date(row.names(df_range)))
indexClass(df_range) <- "Date"
#Create repalace operator
reb_op = ifelse(rebalance=="Never", NA,
ifelse(rebalance=="Annually", "years",
ifelse(rebalance=="Quarterly", "quarters",
"months")))
port_ret = Return.portfolio(df_range, weights = wght, geometric = T, rebalance_on = reb_op)
port_ret = data.frame(port_ret)
colnames(port_ret) = c("RetPort")
return (port_ret)
}
#Function that calculates portfolio performance measures
calcPortMeasures = function (port_ret, benchmark, rf){
mean_rf = mean(rf)
mean_port_ret = mean(port_ret)
sd_port_ret = sd(port_ret)
#Calculate Sharpe
sharpe = ((mean_port_ret - mean_rf) / sd_port_ret) * sqrt(250)
#Calculate Beta
mod = lm(formula = port_ret~benchmark)
beta = summary(mod)$coefficients[2,1]
#Calculate Sortino
sortino = SortinoRatio(port_ret) * sqrt(250)
#Calculate Taylor
treynor = ((mean_port_ret - mean_rf)*250)*100/beta
results = list("AvRet"=mean_port_ret * 250, "StDev" = sd_port_ret * sqrt(250),
"Sharpe" = sharpe, "Sortino" = sortino[1], "Beta" = beta, "Treynor" = treynor)
return (results)
}
mean_ret = apply(df, 2, mean)
mean_ret = apply(df, 2, mean) * 250
cov_matrix = cov(df) * 250
sim_port = simPortfolios(mean_ret, cov_matrix)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5)
ef_w1 = findEfficientFrontier.Return(returns, 0.06/250)
###
library(tseries)
library(dplyr)
library(tibble)
library(PerformanceAnalytics)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5)
ef_w1 = findEfficientFrontier.Return(returns, 0.06/250)
ef_w1 = findEfficientFrontier.Return(returns,target_ret =  0.06)
## Function that finds weights of assets on the efficient frontier
# By target return
findEfficientFrontier.Return = function(zoo, target_ret, short = FALSE){
#Calculate optimal weights
opt.weights = portfolio.optim(returns, pm=target_ret/250, shorts = short)$pw
if (short == FALSE){
opt.weights = pmax(opt.weights, 0) #Correct approximation error
opt.weights = opt.weights/sum(opt.weights)
}
return (opt.weights)
}
ef_w1 = findEfficientFrontier.Return(returns,target_ret =  0.06)
ef_Ret1 = calcPortPerformance(ef_w1, mean_ret, cov_matrix)
ef_Ret1 = calcPortPerformance(ef_w1, mean_ret, cov_matrix)[[1]]
ef_Risk1 = calcPortPerformance(ef_w1, mean_ret, cov_matrix)[[2]]
sum(ef_w1)
ef_w1 = findEfficientFrontier.Return(returns,target_ret =  0.07)
ef_Ret1 = calcPortPerformance(ef_w1, mean_ret, cov_matrix)[[1]]
ef_Risk1 = calcPortPerformance(ef_w1, mean_ret, cov_matrix)[[2]]
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5)
ef_fron1 = data.frame(Riks = ef_Risk1, Return = ef_Ret1)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="yellow")
ef_fron1 = data.frame(Risk = ef_Risk1, Return = ef_Ret1)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="yellow")
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red")
zoo = returns
#Set portfolio
p <- portfolio.spec(assets = colnames(zoo))
library(PortfolioAnalytics)
#Set portfolio
p <- portfolio.spec(assets = colnames(zoo))
p
?add.objective
p
# Add constrains
# Full investment
p = add.constraint(portfolio = p, type = "full_investment")
p = add.constraint(portfolio = p, type = "box", min = 0.00, max = 1.00)
#Add objective
p <- add.objective(portfolio = p, type = "return", name = "mean") #Maximixze mean return
p <- add.constraint(portfolio=p, type = "risk", risk_target= 0.010/sqrt(250))
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "ROI", trace = TRUE)
install.packages("ROI")
library(ROI)
optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "ROI", trace = TRUE)
install.packages("ROI.plugin.glpk")
library(foreach)
library(DEoptim)
install.packages("DEoptim")
library(iterators)
library(fGarch)
install.packages("fGarch")
library(Rglpk)
install.packages("Rglpk")
library(quadprog)
library(ROI)
library(ROI.plugin.glpk)
install.packages("ROI.plugin.glpk")
library(ROI.plugin.glpk)
library(ROI.plugin.quadprog)
library(ROI.plugin.symphony)
library(pso)
library(GenSA)
install.packages("pso")
install.packages("GenSA")
install.packages("MASS")
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "random", trace = TRUE)
opt.weights
ef_w2 = opt.weights$opt_values
ef_w2 = opt.weights$opt_values[[]]
ef_w2 = opt.weights$opt_values[]
View(ef_w2)
ef_w2 = opt.weights$portfolio
View(ef_w2)
ef_w2 = opt.weights$weights
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="orange")
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
#Set portfolio
p = portfolio.spec(assets = colnames(zoo))
# Add constrains
# Full investment
p = add.constraint(portfolio = p, type = "full_investment")
p = add.constraint(portfolio = p, type = "box", min = 0.00)
-2e-6 * 1000000
p = add.constraint(portfolio = p, type = "box", min = -2e-6, max = 1)
#Add objective
p <- add.objective(portfolio = p, type = "return", name = "mean") #Maximixze mean return
p <- add.objective(portf.dn.StdDev, type="risk", name="StdDev",
target=0.01/sqrt(250))
p <- add.objective(portfolio = p, type="risk", name="StdDev",
target=0.01/sqrt(250))
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "random", trace = TRUE)
opt.weights$weights
ef_w2 = opt.weights$weights
sum(ef_w2)
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
#Set portfolio
p = portfolio.spec(assets = colnames(zoo))
# Add constrains
# Full investment
p = add.constraint(portfolio = p, type = "full_investment")
#No short selling
if (short == FALSE) {
p = add.constraint(portfolio = p, type = "box", min = -2e-6, max = 1)
}
p = add.constraint(portfolio = p, type = "box", min = -2e-6, max = 1)
#Add objective
p <- add.objective(portfolio = p, type = "return", name = "mean") #Maximixze mean return
p <- add.objective(portfolio = p, type="risk", name="StdDev",
target=0.10/sqrt(250))
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "random", trace = TRUE)
ef_w2 = opt.weights$weights
sum(ef_w2)
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
#Set portfolio
p = portfolio.spec(assets = colnames(zoo))
# Add constrains
# Full investment
p = add.constraint(portfolio = p, type = "full_investment")
p = add.constraint(portfolio = p, type = "box", min = -2e-6, max = 1)
#Add objective
#p <- add.objective(portfolio = p, type = "return", name = "mean") #Maximixze mean return
p <- add.objective(portfolio = p, type="risk", name="StdDev",
target=0.10/sqrt(250))
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "random", trace = TRUE)
ef_w2 = opt.weights$weights
sum(ef_w2)
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "DEoptim", trace = TRUE)
ef_w2 = opt.weights$weights
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
#Add objective
#p <- add.objective(portfolio = p, type = "return", name = "mean") #Maximixze mean return
p <- add.objective(portfolio = p, type="risk", name="StdDev",
target=0.103/sqrt(250))
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "DEoptim", trace = F)
ef_w2 = opt.weights$weights
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
#Set portfolio
p = portfolio.spec(assets = colnames(zoo))
# Add constrains
# Full investment
p = add.constraint(portfolio = p, type = "full_investment")
#No short selling
if (short == FALSE) {
p = add.constraint(portfolio = p, type = "box", min = -2e-6, max = 1)
}
p = add.constraint(portfolio = p, type = "box", min = -2e-6, max = 1)
#Add objective
#p <- add.objective(portfolio = p, type = "return", name = "mean") #Maximixze mean return
p <- add.objective(portfolio = p, type="risk", name="StdDev",
target=0.103/sqrt(250))
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "DEoptim", trace = TRUE)
ef_w2 = opt.weights$weights
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
install.packages("Rglpk")
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "ROI", trace = TRUE)
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "pso", trace = TRUE)
ef_w2 = opt.weights$weights
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
library(DEoptim)
library(ROI)
require(ROI.plugin.glpk)
require(ROI.plugin.quadprog)
install.packages("ROI.plugin.quadprog")
install.packages("ROI.plugin.glpk")
install.packages("ROI.plugin.glpk")
require(ROI.plugin.quadprog)
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "ROI", trace = TRUE)
ef_w2 = opt.weights$weights
ef_Ret2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[1]]
ef_Risk2 = calcPortPerformance(ef_w2, mean_ret, cov_matrix)[[2]]
ef_fron2 = data.frame(Risk = ef_Risk2, Return = ef_Ret2)
ggplot(data=sim_port, aes(x=Risk, y=Return)) + geom_point(color="gray",alpha=0.5) +
geom_point(data=ef_fron1, aes(x=Risk, y=Return), color="red") +
geom_point(data=ef_fron2, aes(x=Risk, y=Return), color="orange")
library(ROI)
library(DEoptim)
library(ROI)
require(ROI.plugin.glpk)
require(ROI.plugin.quadprog)
#Calculate optimal weights
opt.weights = optimize.portfolio(R=zoo, portfolio = p,
optimize_method = "ROI", trace = TRUE)
ef_w2 = opt.weights$weights
shiny::runApp()
runApp()
runApp()
runApp()
runApp('~/Desktop')
?makeReactiveBinding
runApp()
### Function to perform backtesting
pt_port = function(df){
# Create a dataframe with portfolio and benchmark returns
df_tmp = df %>% mutate(date = as.Date(row.names(df)))
# Portfolio return
port_ret = data.frame(calcPortReturn(df, from = as.Date(input$date_range[1]), to = as.Date(input$date_range[2]),
wght = port_weight$weight, rebalance = as.character(input$rebalance)))
port_ret$date = as.Date(row.names(port_ret))
port_ret = rename(port_ret, Portfolio = RetPort)
# 60/30/10 Portfolio
sixty_port = data.frame(calcPortReturn(df, from = as.Date(input$date_range[1]), to = as.Date(input$date_range[2]),
wght = c(0.6, 0, 0, 0.1, 0.3, 0), rebalance = as.character(input$rebalance)))
sixty_port$date = as.Date(row.names(sixty_port))
sixty_port = rename(sixty_port, R60T10C30 = RetPort)
# Merge into one df
port_ret = merge(port_ret, df_tmp[,c("Russell2000","date")], by = "date", all.x = TRUE)
port_ret = merge(port_ret, sixty_port, by = "date", all.x = TRUE)
return(port_ret)
}
### Function to perform backtesting
bt_port = function(df){
# Create a dataframe with portfolio and benchmark returns
df_tmp = df %>% mutate(date = as.Date(row.names(df)))
# Portfolio return
port_ret = data.frame(calcPortReturn(df, from = as.Date(input$date_range[1]), to = as.Date(input$date_range[2]),
wght = port_weight$weight, rebalance = as.character(input$rebalance)))
port_ret$date = as.Date(row.names(port_ret))
port_ret = rename(port_ret, Portfolio = RetPort)
# 60/30/10 Portfolio
sixty_port = data.frame(calcPortReturn(df, from = as.Date(input$date_range[1]), to = as.Date(input$date_range[2]),
wght = c(0.6, 0, 0, 0.1, 0.3, 0), rebalance = as.character(input$rebalance)))
sixty_port$date = as.Date(row.names(sixty_port))
sixty_port = rename(sixty_port, R60T10C30 = RetPort)
# Merge into one df
port_ret = merge(port_ret, df_tmp[,c("Russell2000","date")], by = "date", all.x = TRUE)
port_ret = merge(port_ret, sixty_port, by = "date", all.x = TRUE)
return(port_ret)
}
runApp()
runApp()
### Function to perform backtesting
bt_port = function(df, from, to, wght, rebalance){
# Create a dataframe with portfolio and benchmark returns
df_tmp = df %>% mutate(date = as.Date(row.names(df)))
# Portfolio return
port_ret = data.frame(calcPortReturn(df, from = as.Date(input$date_range[1]), to = as.Date(input$date_range[2]),
wght = port_weight$weight, rebalance = as.character(input$rebalance)))
port_ret$date = as.Date(row.names(port_ret))
port_ret = rename(port_ret, Portfolio = RetPort)
# 60/30/10 Portfolio
sixty_port = data.frame(calcPortReturn(df, from = as.Date(input$date_range[1]), to = as.Date(input$date_range[2]),
wght = c(0.6, 0, 0, 0.1, 0.3, 0), rebalance = as.character(input$rebalance)))
sixty_port$date = as.Date(row.names(sixty_port))
sixty_port = rename(sixty_port, R60T10C30 = RetPort)
# Merge into one df
port_ret = merge(port_ret, df_tmp[,c("Russell2000","date")], by = "date", all.x = TRUE)
port_ret = merge(port_ret, sixty_port, by = "date", all.x = TRUE)
return(port_ret)
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
